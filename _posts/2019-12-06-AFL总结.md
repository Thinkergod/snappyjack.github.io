---
layout: post
title: AFL工具总结
excerpt: "american fuzzy lop工具使用记录"
categories: [知识总结]
comments: true
---

#### 下载和安装
```bash
wget http://lcamtuf.coredump.cx/afl/releases/afl-latest.tgz
tar -xvf ./afl-latest.tgz
cd afl-2.52b/
sudo make && sudo make install
```
#### 检测是否安装成功
```bash
root@b855926e8d87:~# afl-fuzz 
afl-fuzz 2.52b by <lcamtuf@google.com>

afl-fuzz [ options ] -- /path/to/fuzzed_app [ ... ]

Required parameters:

  -i dir        - input directory with test cases
  -o dir        - output directory for fuzzer findings

```
#### 有源码fuzz
由于我们用afl来fuzz upx项目，这个有源码的要用afl-gcc来编译，所以编辑Makefile文件
```bash
git clone https://github.com/upx/upx.git
cd upx/
vim Makefile
```
添加：`CC = /usr/local/bin/afl-gcc` （我直接在第一行加）

查看位置
```bash
which afl-g++
/usr/local/bin/afl-g++
```
在`./src/Makefile`文件中修改： `CXX ?= /usr/local/bin/afl-g++` （应该在31行）
```bash
cd ./src
vim Makefile
```
对于upx项目,我们还要安装这个
```bash
apt install zlib1g zlib1g-dev
```
对于upx项目,安装lzma-sdk
```bash
root@b855926e8d87:~/upx# git submodule update --init --recursive
Submodule 'src/lzma-sdk' (https://github.com/upx/upx-lzma-sdk.git) registered for path 'src/lzma-sdk'
Cloning into 'src/lzma-sdk'...
remote: Enumerating objects: 440, done.
remote: Total 440 (delta 0), reused 0 (delta 0), pack-reused 440
Receiving objects: 100% (440/440), 334.59 KiB | 289.00 KiB/s, done.
Resolving deltas: 100% (151/151), done.
Checking connectivity... done.
Submodule path 'src/lzma-sdk': checked out '426fe82d122e2cf140a86751055ee523378fe2ef'
```
对于upx项目,安装ucl
```bash
wget http://www.oberhumer.com/opensource/ucl/download/ucl-1.03.tar.gz
tar -xvf ./ucl-1.03.tar.gz
cd ucl-1.03/
./configure && sudo make && sudo make install
export UPX_UCLDIR=/path/to/ucl-1.03    # ！！！！！你自己的路径啊
```
最后到我们编译upx了,可以看到很多afl-cc alf-as的字样
```bash
root@b855926e8d87:~/upx# make all
make -C src all
make[1]: Entering directory '/root/upx/src'
Updating .depend
afl-cc 2.52b by <lcamtuf@google.com>
/usr/local/bin/afl-g++ '-DUPX_VERSION_GITREV="7a3637ff5a80+"' -I/root/ucl-1.03/include -O2 -fno-delete-null-pointer-checks -fno-strict-aliasing -fwrapv -funsigned-char -Wall -W -Wcast-align -Wcast-qual -Wmissing-declarations -Wpointer-arith -Wshadow -Wvla -Wwrite-strings -Werror -o c_file.o -c c_file.cpp
afl-cc 2.52b by <lcamtuf@google.com>
afl-as 2.52b by <lcamtuf@google.com>
```
最后编译生成的文件在src目录下的upx.out

在ida中打开,发现文件变得不同了
```bash
.text:00000000004030E0                 lea     rsp, [rsp-98h]
.text:00000000004030E8                 mov     [rsp+0], rdx
.text:00000000004030EC                 mov     [rsp+arg_0], rcx
.text:00000000004030F1                 mov     [rsp+arg_8], rax
.text:00000000004030F6                 mov     rcx, 5010h
.text:00000000004030FD                 call    __afl_maybe_log_10			#看这里
.text:0000000000403102                 mov     rax, [rsp+arg_8]
.text:0000000000403107                 mov     rcx, [rsp+arg_0]
.text:000000000040310C                 mov     rdx, [rsp+0]
.text:0000000000403110                 lea     rsp, [rsp+98h]
.text:0000000000403118                 push    r15
.text:000000000040311A                 push    r14
.text:000000000040311C                 push    r13
.text:000000000040311E                 push    r12
.text:0000000000403120                 push    rbp
.text:0000000000403121                 push    rbx
.text:0000000000403122                 sub     rsp, 28h
.text:0000000000403126                 mov     [rsp+58h+argc], edi
.text:000000000040312A                 mov     [rsp+58h+argv], argv
.text:000000000040312F                 lea     argc, [rsp+58h+argc] ; argc
.text:0000000000403134                 lea     argv, [rsp+58h+argv] ; argv
.text:0000000000403139                 call    _Z12acc_wildargvPiPPPc ; acc_wildargv(int *,char ***)
.text:000000000040313E                 call    _ZL16upx_sanity_checkv ; upx_sanity_check(void)
.text:0000000000403143                 mov     rdi, cs:opt     ; this
.text:000000000040314A                 call    _ZN9options_t5resetEv ; options_t::reset(void)
.text:000000000040314F                 mov     rax, [rsp+58h+argv]
.text:0000000000403154                 mov     rdx, [rax]
.text:0000000000403157                 test    rdx, rdx
.text:000000000040315A                 jz      loc_403A8A
.text:0000000000403160                 lea     rsp, [rsp-98h]
.text:0000000000403168                 mov     [rsp+58h+var_58], rdx
.text:000000000040316C                 mov     [rsp+58h+c2], rcx
.text:0000000000403171                 mov     [rsp+58h+argv], rax
.text:0000000000403176                 mov     rcx, 3887h
.text:000000000040317D                 call    __afl_maybe_log_10			#看这里
```
开启core dump
```bash
echo core >/proc/sys/kernel/core_pattern
```
开始fuzz（下面用file文件作为样本）
```bash
root@giant:~/aflfuzz/fuzztarget/upx# mkdir afl_in afl_out
root@giant:~/aflfuzz/fuzztarget/upx# cp /usr/bin/file afl_in
root@giant:~/aflfuzz/fuzztarget/upx# afl-fuzz -i afl_in -o afl_out ./src/upx.out @@		#其中./src/upx.out为运行的文件
```
运行界面
```bash
                       american fuzzy lop 2.52b (upx.out)

lq process timing qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqwq overall results qqqqqk
x        run time : 0 days, 0 hrs, 3 min, 38 sec       x  cycles done : 0      x
x   last new path : 0 days, 0 hrs, 1 min, 0 sec        x  total paths : 50     x
x last uniq crash : none seen yet                      x uniq crashes : 0      x
x  last uniq hang : none seen yet                      x   uniq hangs : 0      x
tq cycle progress qqqqqqqqqqqqqqqqqqqqwq map coverage qvqqqqqqqqqqqqqqqqqqqqqqqu
x  now processing : 0 (0.00%)         x    map density : 2.13% / 3.27%         x
x paths timed out : 0 (0.00%)         x count coverage : 1.20 bits/tuple       x
tq stage progress qqqqqqqqqqqqqqqqqqqqnq findings in depth qqqqqqqqqqqqqqqqqqqqu
x  now trying : bitflip 2/1           x favored paths : 1 (2.00%)              x
x stage execs : 60.7k/152k (39.77%)   x  new edges on : 40 (80.00%)            x
x total execs : 215k                  x total crashes : 0 (0 unique)           x
x  exec speed : 992.1/sec             x  total tmouts : 0 (0 unique)           x
tq fuzzing strategy yields qqqqqqqqqqqvqqqqqqqqqqqqqqqwq path geometry qqqqqqqqu
x   bit flips : 45/152k, 0/0, 0/0                     x    levels : 2          x
x  byte flips : 0/0, 0/0, 0/0                         x   pending : 50         x
x arithmetics : 0/0, 0/0, 0/0                         x  pend fav : 1          x
x  known ints : 0/0, 0/0, 0/0                         x own finds : 49         x
x  dictionary : 0/0, 0/0, 0/0                         x  imported : n/a        x
x       havoc : 0/0, 0/0                              x stability : 100.00%    x
x        trim : 0.00%/1181, n/a                       tqqqqqqqqqqqqqqqqqqqqqqqqj
mqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqj          [cpu000: 50%]

```

#### 无源码fuzz
对无源码的程序进行fuzz一般有两种方法:
- 对二进制文件进行插桩
- 使用-n选项进行传统的fuzz测试

第一种由afl-qemu实现，如果使用第二种方法，把-Q改成-n就行

**编译一个AFL版的qemu**
```bash
root@giant:~/aflfuzz/afl-2.52b# cd qemu_mode/
root@giant:~/aflfuzz/afl-2.52b/qemu_mode# ls
build_qemu_support.sh  patches  README.qemu
root@giant:~/aflfuzz/afl-2.52b/qemu_mode# ./build_qemu_support.sh 
root@giant:~/aflfuzz/afl-2.52b/qemu_mode#cp ../afl-qemu-trace /usr/local/bin/
```
如果缺少libtool
```bash
apt install libtool-bin
```
**Error: devel version of 'glib2' not found, please install first.**
```bash
apt-get install libgtk2.0-dev
```
最终显示
```bash
[+] Build process successful!
[*] Copying binary...
-rwxr-xr-x 1 root root 10351056 Dec  6 08:14 ../afl-qemu-trace
[+] Successfully created '../afl-qemu-trace'.
[*] Testing the build...
[+] Instrumentation tests passed. 
[+] All set, you can now use the -Q mode in afl-fuzz!

```
**下面使用无源码方式fuzz readelf**
同样也是创建文件夹，放入原始样本（test你自己准备吧）
```bash
mkdir afl_in afl_out
mv test ./afl_in/										#这个是readelf需要读取的文件
cp /usr/bin/readelf .
afl-fuzz -i afl_in -o afl_out -Q ./readelf -a @@		#-Q就是无源码进行二进制插装fuzz,如果选传统fuzz,把-Q改成-n就行
```
运行界面
```bash

                       american fuzzy lop 2.52b (readelf)

lq process timing qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqwq overall results qqqqqk
x        run time : 0 days, 0 hrs, 0 min, 18 sec       x  cycles done : 0      x
x   last new path : 0 days, 0 hrs, 0 min, 0 sec        x  total paths : 77     x
x last uniq crash : none seen yet                      x uniq crashes : 0      x
x  last uniq hang : none seen yet                      x   uniq hangs : 0      x
tq cycle progress qqqqqqqqqqqqqqqqqqqqwq map coverage qvqqqqqqqqqqqqqqqqqqqqqqqu
x  now processing : 0 (0.00%)         x    map density : 2.89% / 3.98%         x
x paths timed out : 0 (0.00%)         x count coverage : 1.55 bits/tuple       x
tq stage progress qqqqqqqqqqqqqqqqqqqqnq findings in depth qqqqqqqqqqqqqqqqqqqqu
x  now trying : bitflip 1/1           x favored paths : 1 (1.30%)              x
x stage execs : 1006/50.4k (2.00%)    x  new edges on : 52 (67.53%)            x
x total execs : 3181                  x total crashes : 0 (0 unique)           x
x  exec speed : 122.2/sec             x  total tmouts : 0 (0 unique)           x
tq fuzzing strategy yields qqqqqqqqqqqvqqqqqqqqqqqqqqqwq path geometry qqqqqqqqu
x   bit flips : 0/0, 0/0, 0/0                         x    levels : 2          x
x  byte flips : 0/0, 0/0, 0/0                         x   pending : 77         x
x arithmetics : 0/0, 0/0, 0/0                         x  pend fav : 1          x
x  known ints : 0/0, 0/0, 0/0                         x own finds : 76         x
x  dictionary : 0/0, 0/0, 0/0                         x  imported : n/a        x
x       havoc : 0/0, 0/0                              x stability : 100.00%    x
x        trim : 0.00%/1558, n/a                       tqqqqqqqqqqqqqqqqqqqqqqqqj
mqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqj          [cpu000: 50%]

```

-----
#### 什么是Qemu 
Qemu 是纯软件实现的虚拟化模拟器，几乎可以模拟任何硬件设备，我们最熟悉的就是能够模拟一台能够独立运行操作系统的虚拟机，虚拟机认为自己和硬件打交道，但其实是和 Qemu 模拟出来的硬件打交道，Qemu 将这些指令转译给真正的硬件。

正因为 Qemu 是纯软件实现的，所有的指令都要经 Qemu 过一手，性能非常低，所以，在生产环境中，大多数的做法都是配合 KVM 来完成虚拟化工作，因为 KVM 是硬件辅助的虚拟化技术，主要负责 比较繁琐的 CPU 和内存虚拟化，而 Qemu 则负责 I/O 虚拟化，两者合作各自发挥自身的优势，相得益彰。

