---
layout: post
title: pwn lctf2018 easy_heap
excerpt: "lctf2018 easy_heap writeup"
categories: [未完待续]
comments: true
---

#### 堆块重用机制
在chunk结构的学习中我们已经了解到，presize字段仅在前一个堆块是空闲时才有意义，也就是说，当前一个堆块是inuse态时，presize是可有可无的。考虑到这一点，libc采用了一种机制：当一个堆块是inuse态时，它会把下一个堆块的presize字段也作为自己的用户区，这样就可以节省内存空间，这种把presize字段在pre_chunk非空闲时用作pre_chunk的数据区的处理机制就是堆块重用。

**然而，并不是所有情况下都会使用堆块重用！这也是今天要讲的要点：**

我们知道，堆块分配时，它的大小要进行内存对齐，32位操作系统中，会以8字节进行对齐（即堆块的大小必须是8字节的整数倍），而64位操作系统中，会以16字节进行对齐（即堆块的大小必须是16字节的整数倍）。

而堆块重用只出现在如下情况：申请的内存大小在按照上述规则进行向大取整后，得到的应有大小比原大小大出的值大于等于对齐字节量的一半！

比如64位操作系统中，malloc(0x88)，向大取整后是0x90，比原来大出了8个字节，而64位下的对齐字节量是16字节，8字节大于等于16的一半，因此会进行堆块重用：0x88中的最后8字节会存在下一个chunk的presize字段位置。而如果是malloc(0x79)，向大取整后是0x80，比原来大出7个字节，小于16的一半，就不会发生堆块重用。

为什么呢？堆块重用的初衷就是节约内存，当符合上述重用条件时，用户申请的大小mod对齐字节量后多出的那块大小是小于等于presize字段长度（如64位下是8字节）的，因此多出的这块小尾巴就正好可以顺便放进presize字段存储，相比来说，如果不重用presize来存，而是继续按16字节对齐，将会产生较大的内存浪费；而当不符合重用条件时，多出来的小尾巴是大于presize长度的，presize就存不下了，而size字段人家自己还有用你又不能拿来占，因此就没法进行堆块重用了。

总结一下堆块重用条件：申请的内存大小在按照上述规则进行向大取整后，得到的应有大小比原大小大出的值>=对齐字节量的一半（presize字段长度）.    =>也即：申请的内存大小mod对齐字节量<=对齐字节量的一半（presize字段长度）.

#### size字段对齐计算方式
size字段的值 = 对齐补齐( size字段长度 + 用户申请的长度 )

我们分用户申请的堆块采用了重用和未采用重用两种情况来看：

1. 未采用重用：
```
|用户申请长度|        
 ----------------
|xxxxxxxx|xxx    |
|----------------|
|size长度|       |
|----------------|
|        |       |
 ----------------
```
如上图，每格代表32位下的4字节或64位下的8字节，按计算公式进行对齐补齐后，共应占4个格，4个格子的长度即为size的值.

2. 采用重用：
```
|用户申请长度|        
 -----------------
|xxxxxxxx|xxxxxxxx|
|-----------------|
|xxx|    |size长度|
|-----------------|
|        |        |
 ----------------
```
如上图，每格代表32位下的4字节或64位下的8字节，按计算公式进行对齐补齐后，共应占4个格，4个格子的长度即为size的值.

我们发现：当采用了重用时，计算出来的size字段的值是舍弃了“小尾巴”的，即重用的presize字段长度并未算进来！

也就是说，无论是否重用，抽象掉计算过程来看，最终得到的size字段值一定是从chunk_head到next_chunk_head间的长度！

**注意**
1. off by one 可以覆盖inuse位：必须在进行了重用的情况下才能实现！
2. 泄露堆地址时，加减的偏移量应取多少，需要考虑是否有重用！

#### 升级到gcc 6.3：
```bash
yum -y install centos-release-scl
yum -y install devtoolset-6-gcc devtoolset-6-gcc-c++ devtoolset-6-binutils
scl enable devtoolset-6 bash
```
需要注意的是scl命令启用只是临时的，退出shell或重启就会恢复原系统gcc版本。
如果要长期使用gcc 6.3的话：
```bash
echo "source /opt/rh/devtoolset-6/enable" >>/etc/profile
```
这样退出shell重新打开就是新版的gcc了





