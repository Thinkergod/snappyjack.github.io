---
layout: post
title: 理解DynELF
excerpt: "关于DynELF的总结"
categories: [关于pwn的知识]
comments: true
---


symbol resolution

就是在不知道offset的情况下，如何找到offset，从而return to libc

ELF结构如下：

![image](https://note.youdao.com/yws/public/resource/2534f9760353375374772b119a101834/xmlnote/97FE9772BF0B47BFBBB409378F8F1D39/14626)

指定dynamic linker
```
gcc a.c -o a -Wl,-dynamic-linker /home/xxxx/lib/ld-2.19.so -g
```

当函数第一次被呼叫时候，通过dynamic resolver 来计算函数地址，并卸载got位置上
```shell
gdb-peda$ disass 0x8048340
Dump of assembler code for function write@plt:
   0x08048340 <+0>:	jmp    DWORD PTR ds:0x804a018
   0x08048346 <+6>:	push   0x18
   0x0804834b <+11>:jmp    0x8048300
```
`0x8048300`这个位置其实是plt的第0个entry，plt entry的结构如下
```
gdb-peda$ x/32i 0x8048300
   0x8048300:	push   DWORD PTR ds:0x804a004
   0x8048306:	jmp    DWORD PTR ds:0x804a008
   0x804830c:	add    BYTE PTR [eax],al
   0x804830e:	add    BYTE PTR [eax],al
   0x8048310 <read@plt>:	jmp    DWORD PTR ds:0x804a00c
   0x8048316 <read@plt+6>:	push   0x0
   0x804831b <read@plt+11>:	jmp    0x8048300
   0x8048320 <__gmon_start__@plt>:	jmp    DWORD PTR ds:0x804a010
   0x8048326 <__gmon_start__@plt+6>:	push   0x8
   0x804832b <__gmon_start__@plt+11>:	jmp    0x8048300
   0x8048330 <__libc_start_main@plt>:	jmp    DWORD PTR ds:0x804a014
   0x8048336 <__libc_start_main@plt+6>:	push   0x10
   0x804833b <__libc_start_main@plt+11>:	jmp    0x8048300
   0x8048340 <write@plt>:	jmp    DWORD PTR ds:0x804a018
   0x8048346 <write@plt+6>:	push   0x18
   0x804834b <write@plt+11>:	jmp    0x8048300
```
其中`0x8048306`这一行所作的事情就是进入到`_dl_runtime_resolve`中

ELF结构与运行时ELF结构(执行时候没有section header table,且结构变为Segment)
```
ELF Header  			| ELF Header 
Program header table	| Program header table
Section1				| Segment1
Section2				| Segment2
...						| ...
Section header table
``` 


查看所有elf结构：`readelf -aW level4 |less`

查看某个section
```
objdump -j .got.plt -s level4

level4：     文件格式 elf32-i386

Contents of section .got.plt:
 804a000 149f0408 00000000 00000000 16830408  ................
 804a010 26830408 36830408 46830408           &...6...F...    
```
#### 解析elf
运行`readelf -aW test |less`查看ELF Header如下
```
ELF 头：
  Magic：  7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 
  类别:                              ELF64
  数据:                              2 补码，小端序 (little endian)
  版本:                              1 (current)
  OS/ABI:                            UNIX - System V
  ABI 版本:                          0
  类型:                              EXEC (可执行文件)
  系统架构:                          Advanced Micro Devices X86-64
  版本:                              0x1
  入口点地址：              0x400470
  程序头起点：              64 (bytes into file)
  Start of section headers:          6512 (bytes into file)
  标志：             0x0
  本头的大小：       64 (字节)
  程序头大小：       56 (字节)
  Number of program headers:         9
  节头大小：         64 (字节)
  节头数量：         31
  字符串表索引节头： 30
```
通过`程序头起点`和`Start of section headers`来查找segments和section地址

查看是否为elf文件起始地址
```
gdb-peda$ x/s 0x400000
0x400000:	"\177ELF\002\001\001"
```
格式化elfheader
```shell
gdb-peda$ p/x *(Elf64_Ehdr*)0x400000
$1 = {
  e_ident = {0x7f, 0x45, 0x4c, 0x46, 0x2, 0x1, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, 
  e_type = 0x2, 
  e_machine = 0x3e, 
  e_version = 0x1, 
  e_entry = 0x400470, 
  e_phoff = 0x40, 	//program header offset
  e_shoff = 0x1970, 
  e_flags = 0x0, 
  e_ehsize = 0x40, 
  e_phentsize = 0x38, 
  e_phnum = 0x9, 		//number of program header
  e_shentsize = 0x40, 
  e_shnum = 0x1f, 
  e_shstrndx = 0x1e
}
```
e_phoff和e_shoff分别是program header和 section header的offset，和`readelf -aW test |less`给出的结果一致

查看第0个program header
```

gdb-peda$ p/x *(Elf64_Phdr*)0x400040
$1 = {
  p_type = 0x6, 
  p_flags = 0x5, 
  p_offset = 0x40, 
  p_vaddr = 0x400040, 
  p_paddr = 0x400040, 
  p_filesz = 0x1f8, 
  p_memsz = 0x1f8, 
  p_align = 0x8
}
}
```
查看第5个program header
```bash
gdb-peda$ p/x ((Elf64_Phdr*)0x400040)[5]
$2 = {
  p_type = 0x4, 
  p_flags = 0x4, 
  p_offset = 0x254, 
  p_vaddr = 0x400254, 
  p_paddr = 0x400254, 
  p_filesz = 0x44, 
  p_memsz = 0x44, 
  p_align = 0x4
}
```
查看前三个program header
```bash
gdb-peda$ p/x *(Elf64_Phdr*)0x400040@3
$3 = {{
    p_type = 0x6, 
    p_flags = 0x5, 
    p_offset = 0x40, 
    p_vaddr = 0x400040, 
    p_paddr = 0x400040, 
    p_filesz = 0x1f8, 
    p_memsz = 0x1f8, 
    p_align = 0x8
  }, {
    p_type = 0x3, 
    p_flags = 0x4, 
    p_offset = 0x238, 
    p_vaddr = 0x400238, 
    p_paddr = 0x400238, 
    p_filesz = 0x1c, 
    p_memsz = 0x1c, 
    p_align = 0x1
  }, {
    p_type = 0x1, 
    p_flags = 0x5, 
    p_offset = 0x0, 
    p_vaddr = 0x400000, 
    p_paddr = 0x400000, 
    p_filesz = 0x7b4, 
    p_memsz = 0x7b4, 
    p_align = 0x200000
  }}
  
```
从program header table中找出dynamic section位置：

- 找出p_type的值为PT_DYNAMIC(值为0x2)的program header
- Base加上p_offset 即为`.dynamic`

找到的内容如下
```
  p_type = 0x2, 
    p_flags = 0x6, 
    p_offset = 0xe28, 
    p_vaddr = 0x600e28, 	\\.dynamic section 位置
    p_paddr = 0x600e28, 
    p_filesz = 0x1d0, 
    p_memsz = 0x1d0, 
    p_align = 0x8

```
在没有开aslr情况下，通过`readelf -aW test |less`从section header中找到
```
  [22] .dynamic          DYNAMIC         0000000000600e28 000e28 0001d0 10  WA  6   0  8
  [23] .got              PROGBITS        0000000000600ff8 000ff8 000008 08  WA  0   0  8
  [24] .got.plt          PROGBITS        0000000000601000 001000 000030 08  WA  0   0  8
```
记录一下dynamic
```
set $dynamic = 0x600e28
```
dynamic section也是table，查看第0个dynamic section
```
gdb-peda$ set $dynamic = (Elf64_Dyn*)0x600e28
gdb-peda$ p/x *$dynamic
$12 = {
  d_tag = 0x1, 
  d_un = {
    d_val = 0x1, 
    d_ptr = 0x1
  }
}

```
查看前6个dynamic section
```
gdb-peda$ p/x *$dynamic@6
$6 = {{
    d_tag = 0x1, 
    d_un = {
      d_val = 0x1, 
      d_ptr = 0x1
    }
  }, {
    d_tag = 0xc, 
    d_un = {
      d_val = 0x400400, 
      d_ptr = 0x400400
    }
  }, {
    d_tag = 0xd, 
    d_un = {
      d_val = 0x400664, 
      d_ptr = 0x400664
    }
  }, {
    d_tag = 0x19, 
    d_un = {
      d_val = 0x600e10, 
      d_ptr = 0x600e10
    }
  }, {
    d_tag = 0x1b, 
    d_un = {
      d_val = 0x8, 
      d_ptr = 0x8
    }
  }, {
    d_tag = 0x1a, 
    d_un = {
      d_val = 0x600e18, 
      d_ptr = 0x600e18
    }
  }}

```
同样通过`readelf -aW test |less`也可以找到
```
Dynamic section at offset 0xe28 contains 24 entries:
  标记        类型                         名称/值
 0x0000000000000001 (NEEDED)             共享库：[libc.so.6]
 0x000000000000000c (INIT)               0x400400
 0x000000000000000d (FINI)               0x400664
 0x0000000000000019 (INIT_ARRAY)         0x600e10
 0x000000000000001b (INIT_ARRAYSZ)       8 (bytes)
 0x000000000000001a (FINI_ARRAY)         0x600e18
 0x000000000000001c (FINI_ARRAYSZ)       8 (bytes)
 0x000000006ffffef5 (GNU_HASH)           0x400298
 0x0000000000000005 (STRTAB)             0x400330
 0x0000000000000006 (SYMTAB)             0x4002b8
 0x000000000000000a (STRSZ)              68 (bytes)
 0x000000000000000b (SYMENT)             24 (bytes)
...
...
```
dynsym Section表示program中用到的所有symbol

查找`.dynsym Section`:`.dynamic`中d_tag为DT_SYMTAB(为6)的entry，d_ptr指向`.dynsym section`

如上边显示的
```
   d_tag = 0x6, 
    d_un = {
      d_val = 0x4002b8, 
      d_ptr = 0x4002b8

或者
0x0000000000000006 (SYMTAB)             0x4002b8
```
在setion header中也可以看到
```
[ 5] .dynsym           DYNSYM          00000000004002b8 0002b8 000078 18   A  6   1  8
```
d_tag为5的是synstr
```
0x0000000000000005 (STRTAB)             0x400330
或者
    d_tag = 0x5, 
    d_un = {
      d_val = 0x400330, 
      d_ptr = 0x400330

```

```
gdb-peda$ set $dynstr = (char*)0x400330
gdb-peda$ set $dynsym = (Elf64_Sym*)0x4002b8
```
查看dynstr
```
gdb-peda$ x/20s 0x400330
0x400330:	""
0x400331:	"libc.so.6"
0x40033b:	"puts"
0x400340:	"memset"
0x400347:	"__libc_start_main"
0x400359:	"__gmon_start__"
0x400368:	"GLIBC_2.2.5"
0x400374:	""
```
查看第一个dynsym
```
gdb-peda$ p/x $dynsym[1]
$8 = {
  st_name = 0xb, 
  st_info = 0x12, 
  st_other = 0x0, 
  st_shndx = 0x0, 
  st_value = 0x0, 
  st_size = 0x0
}

```
查看第一个symbol name
```
gdb-peda$ p/s $dynstr+0xb
$9 = 0x40033b "puts"
```
查看.rel.plt(.rela.plt)，找到这个section的位置
```
0x0000000000000017 (JMPREL)             0x4003b8

```
记录一下
```
set $rela = (Elf64_Rela*)0x4003b8
```
查看前三个rela
```
gdb-peda$ p/x *$rela@3
$6 = {{
    r_offset = 0x601018, //要做relocation的位置，即GOT entry，每一个offset就是一个got的位置
    r_info = 0x100000007, //symbol的index，在.dynsym的index
    r_addend = 0x0
  }, {
    r_offset = 0x601020, 
    r_info = 0x200000007, 
    r_addend = 0x0
  }, {
    r_offset = 0x601028, 
    r_info = 0x300000007, 
    r_addend = 0x0
  }}

```
例子：
```
gdb-peda$ p/s $dynstr + $dynsym[1]->st_name
$7 = 0x40033b "puts"
```
然后通过rela的索引，找到got位置，填写进去

push的index，就是告诉resolver需要解析的symbol时什么

Dynamic Resolver流程
```shell
_dl_runtime_resolve(link_map,reloc_arg)
                               |
           __________          |
          |Elf64_Rel |<--------+
          |----------|
    +-----|r_offset  |        ___________
    |     |r_info    |------>| Elf64_Sym |           __________
    |     |__________|       |-----------|          |          |
    |       .rel.plt         | st_name   |--------->| printf\0 |
 ___|_____                   |___________|          |__________|
|         |                     .dynsym                .dynstr
|<printf> |
|_________|
  .got.plt

```
这个流程就是说，通过reloc_arg这个参数，最终可以获得function的名称和gotentry位置

#### 查找link_map

1. 查找`.got.plt`的位置
```shell
readelf -aW test | grep plt
 ...
 ...
  [24] .got.plt          PROGBITS        0000000000601000 001000 000030 08  WA  0   0  8

```
查看`.got.plt`的三个entry
```
db-peda$ x/3gx 0x0000000000601000
0x601000:	0x0000000000600e28	0x00007ffff7ffe150
0x601010:	0x00007ffff7df1910
```
第二个如下
```
gdb-peda$ x/i 0x00007ffff7df1910
   0x7ffff7df1910 <_dl_runtime_resolve_xsave>:	push   rbx

```
第一个就是link_map
```
gdb-peda$ p/x *(struct link_map*)0x00007ffff7ffe150
$1 = {
  l_addr = 0x0, 
  l_name = 0x7ffff7df7f1a, 
  l_ld = 0x600e28, 
  l_next = 0x7ffff7ffe6e0, 
  l_prev = 0x0, 
  l_real = 0x7ffff7ffe150, 
  l_ns = 0x0, 
  l_libname = 0x7ffff7ffe6c0, 
  l_info = {0x0, 0x600e28, 0x600f08, 0x600ef8, 0x0, 0x600ea8, 0x600eb8, 0x600f38, 0x600f48, 0x600f58, 0x600ec8, 0x600ed8, 
    0x600e38, 0x600e48, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x600f18, 0x600ee8, 0x0, 0x600f28, 0x0, 0x600e58, 0x600e78, 
    0x600e68, 0x600e88, 0x0, 0x0, 0x0, 0x0, 0x0, 0x600f78, 0x600f68, 0x0 <repeats 13 times>, 0x600f88, 
    0x0 <repeats 25 times>, 0x600e98}, 
  l_phdr = 0x400040, 
  l_entry = 0x400470, 
  l_phnum = 0x9, 
  l_ldnum = 0x0, 
  l_searchlist = {
    r_list = 0x7ffff7ff9b50, 
    r_nlist = 0x3
  }, 
  l_symbolic_searchlist = {
    r_list = 0x7ffff7ffe6b8, 
    r_nlist = 0x0
  }, 
  l_loader = 0x0, 
  l_versions = 0x7ffff7ff9b68, 
  l_nversions = 0x3, 
  l_nbuckets = 0x1, 
  l_gnu_bitmask_idxbits = 0x0, 
  l_gnu_shift = 0x0, 
  l_gnu_bitmask = 0x4002a8, 
  {
    l_gnu_buckets = 0x4002b0, 
    l_chain = 0x4002b0
  }, 
  {
    l_gnu_chain_zero = 0x4002b0, 
    l_buckets = 0x4002b0
  }, 
  l_direct_opencount = 0x1, 
  l_type = 0x0, 
  l_relocated = 0x1, 
  l_init_called = 0x1, 
  l_global = 0x1, 
  l_reserved = 0x0, 
  l_phdr_allocated = 0x0, 
  l_soname_added = 0x0, 
  l_faked = 0x0, 
  l_need_tls_init = 0x0, 
  l_auditing = 0x0, 
  l_audit_any_plt = 0x0, 
  l_removed = 0x0, 
  l_contiguous = 0x0, 
  l_symbolic_in_local_scope = 0x0, 
  l_free_initfini = 0x0, 
  l_rpath_dirs = {
    dirs = 0xffffffffffffffff, 
    malloced = 0x0
  }, 
  l_reloc_result = 0x0, 
  l_versyms = 0x400374, 
  l_origin = 0x0, 
  l_map_start = 0x400000, 
  l_map_end = 0x601038, 
  l_text_end = 0x4007b4, 
  l_scope_mem = {0x7ffff7ffe408, 0x0, 0x0, 0x0}, 
  l_scope_max = 0x4, 
  l_scope = 0x7ffff7ffe4a8, 
  l_local_scope = {0x7ffff7ffe408, 0x0}, 
  l_dev = 0x0, 
  l_ino = 0x0, 
  l_runpath_dirs = {
    dirs = 0xffffffffffffffff, 
    malloced = 0x0
  }, 
  l_initfini = 0x7ffff7ff9b30, 
  l_reldeps = 0x0, 
  l_reldepsmax = 0x0, 
  l_used = 0x1, 
  l_feature_1 = 0x0, 
  l_flags_1 = 0x0, 
  l_flags = 0x0, 
  l_idx = 0x0, 
  l_mach = {
    plt = 0x0, 
    gotplt = 0x0, 
    tlsdesc_table = 0x0
  }, 
  l_lookup_cache = {
    sym = 0x400318, 
    type_class = 0x0, 
    value = 0x0, 
    ret = 0x0
  }, 
  l_tls_initimage = 0x0, 
  l_tls_initimage_size = 0x0, 
  l_tls_blocksize = 0x0, 
  l_tls_align = 0x0, 
  l_tls_firstbyte_offset = 0x0, 
  l_tls_offset = 0x0, 
  l_tls_modid = 0x0, 
  l_relro_addr = 0x600e10, 
  l_relro_size = 0x1f0, 
  l_serial = 0x0, 
  l_audit = 0x7ffff7ffe5b8
}
```
保存，查看linkmap
```
gdb-peda$ set $l = (struct link_map*)0x00007ffff7ffe150
gdb-peda$ p/x $l->l_name
$2 = 0x7ffff7df7f1a
gdb-peda$ p/x $l->l_addr
$3 = 0x0
```
指向下一个（刚才的第一个是binrary自己）
```
gdb-peda$ p/x $l->l_next
$3 = 0x7ffff7ffe6e0
```
还可以继续往下串
```
gdb-peda$ p/x $l->l_next->l_next
$5 = 0x7ffff7ff9658
```
查看`l_name`
```
gdb-peda$ p/s $l->l_next->l_next->l_name
$14 = 0x7ffff7ff9640 "/lib64/libc.so.6"
gdb-peda$ p/s $l->l_next->l_next->l_next->l_name
$15 = 0x400238 "/lib64/ld-linux-x86-64.so.2"
```
保存一下
```
gdb-peda$ set $l2 = $l->l_next->l_next
gdb-peda$ p/s $l2->l_name
$16 = 0x7ffff7ff9640 "/lib64/libc.so.6"
```
查看libc的link_map
```
gdb-peda$ p/x *$l2
$13 = {
  l_addr = 0x7ffff7a0d000, 
  l_name = 0x7ffff7ff9640, 
  l_ld = 0x7ffff7dd3b60, 
  l_next = 0x7ffff7ffd998, 
  l_prev = 0x7ffff7ffe6e0, 
  l_real = 0x7ffff7ff9658, 
  l_ns = 0x0, 
  l_libname = 0x7ffff7ff9ac8, 
  l_info = {0x0, 0x7ffff7dd3b60, 0x7ffff7dd3c20, 0x7ffff7dd3c10, 0x7ffff7dd3bb0, 0x7ffff7dd3bd0, 0x7ffff7dd3be0, 
    0x7ffff7dd3c50, 0x7ffff7dd3c60, 0x7ffff7dd3c70, 0x7ffff7dd3bf0, 0x7ffff7dd3c00, 0x7ffff7dd3b80, 0x0, 0x7ffff7dd3b70, 
    0x0, 0x0, 0x0, 0x0, 0x0, 0x7ffff7dd3c30, 0x0, 0x0, 0x7ffff7dd3c40, 0x7ffff7dd3cb0, 0x7ffff7dd3b90, 0x0, 
    0x7ffff7dd3ba0, 0x0, 0x0, 0x7ffff7dd3ca0, 0x0, 0x0, 0x0, 0x7ffff7dd3cd0, 0x7ffff7dd3cc0, 0x7ffff7dd3c90, 
    0x7ffff7dd3c80, 0x7ffff7dd3cb0, 0x0, 0x7ffff7dd3cf0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x7ffff7dd3ce0, 
    0x0 <repeats 25 times>, 0x7ffff7dd3bc0}, 
  l_phdr = 0x7ffff7a0d040, 
  l_entry = 0x7ffff7a2f610, 
  l_phnum = 0xa, 
  l_ldnum = 0x1f, 
  l_searchlist = {
    r_list = 0x0, 
    r_nlist = 0x0
  }, 
  l_symbolic_searchlist = {
    r_list = 0x7ffff7ff9ac0, 
    r_nlist = 0x0
  }, 
  l_loader = 0x7ffff7ffe150, 
  l_versions = 0x7ffff7ff9bf8, 
  l_nversions = 0x19, 
  l_nbuckets = 0x3f3, 
  l_gnu_bitmask_idxbits = 0xff, 
  l_gnu_shift = 0xe, 
  l_gnu_bitmask = 0x7ffff7a0d2c8, 
  {
    l_gnu_buckets = 0x7ffff7a0dac8, 
    l_chain = 0x7ffff7a0dac8
  }, 
  {
    l_gnu_chain_zero = 0x7ffff7a0ea78, 
    l_buckets = 0x7ffff7a0ea78
  }, 
  l_direct_opencount = 0x0, 
  l_type = 0x1, 
  l_relocated = 0x1, 
  l_init_called = 0x1, 
  l_global = 0x1, 
  l_reserved = 0x0, 
  l_phdr_allocated = 0x0, 
  l_soname_added = 0x0, 
  l_faked = 0x0, 
  l_need_tls_init = 0x0, 
  l_auditing = 0x0, 
  l_audit_any_plt = 0x0, 
  l_removed = 0x0, 
  l_contiguous = 0x1, 
  l_symbolic_in_local_scope = 0x0, 
  l_free_initfini = 0x0, 
  l_rpath_dirs = {
    dirs = 0x0, 
    malloced = 0x0
  }, 
  l_reloc_result = 0x0, 
  l_versyms = 0x7ffff7a23ace, 
  l_origin = 0x7ffff7ff9af0, 
  l_map_start = 0x7ffff7a0d000, 
  l_map_end = 0x7ffff7dda1e0, 
  l_text_end = 0x7ffff7bd0000, 
  l_scope_mem = {0x7ffff7ffe408, 0x0, 0x0, 0x0}, 
  l_scope_max = 0x4, 
  l_scope = 0x7ffff7ff99b0, 
  l_local_scope = {0x7ffff7ff9910, 0x0}, 
  l_dev = 0xfd00, 
  l_ino = 0x2dcdff, 
  l_runpath_dirs = {
    dirs = 0x0, 
    malloced = 0x0
  }, 
  l_initfini = 0x7ffff7ff9b08, 
  l_reldeps = 0x0, 
  l_reldepsmax = 0x0, 
  l_used = 0x1, 
  l_feature_1 = 0x0, 
  l_flags_1 = 0x1, 
  l_flags = 0x18, 
  l_idx = 0x0, 
  l_mach = {
    plt = 0x0, 
    gotplt = 0x0, 
    tlsdesc_table = 0x0
  }, 
  l_lookup_cache = {
    sym = 0x7ffff7a15528, 
    type_class = 0x1, 
    value = 0x7ffff7ff9658, 
    ret = 0x7ffff7a15528
  }, 
  l_tls_initimage = 0x7ffff7dd0700, 
  l_tls_initimage_size = 0x10, 
  l_tls_blocksize = 0xa0, 
  l_tls_align = 0x10, 
  l_tls_firstbyte_offset = 0x0, 
  l_tls_offset = 0xa0, 
  l_tls_modid = 0x1, 
  l_relro_addr = 0x3c3700, 
  l_relro_size = 0x3900, 
  l_serial = 0x3, 
  l_audit = 0x7ffff7ff9ac0
}
```
**其中l_addr是libc的基地址**

查看l_info
```
gdb-peda$ p/x $l->l_info
$22 = {0x0, 0x600e28, 0x600f08, 0x600ef8, 0x0, 0x600ea8, 0x600eb8, 0x600f38, 0x600f48, 0x600f58, 0x600ec8, 0x600ed8, 
  0x600e38, 0x600e48, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x600f18, 0x600ee8, 0x0, 0x600f28, 0x0, 0x600e58, 0x600e78, 0x600e68, 
  0x600e88, 0x0, 0x0, 0x0, 0x0, 0x0, 0x600f78, 0x600f68, 0x0 <repeats 13 times>, 0x600f88, 0x0 <repeats 25 times>, 
  0x600e98}
```
l_info[x]指向`.dynamic`中d_tag = x 的栏位，可以拿到library中的各个section
```
gdb-peda$ p/x $l->l_info[1]
$25 = 0x600e28
gdb-peda$ p/x *(Elf64_Dyn*)$l->l_info[1]
$26 = {
  d_tag = 0x1, 
  d_un = {
    d_val = 0x1, 
    d_ptr = 0x1
  }
}
```
所以也可以这样找
```
gdb-peda$ p/x *(Elf64_Dyn*)$l->l_info[6]
$27 = {
  d_tag = 0x6, 
  d_un = {
    d_val = 0x4002b8, 
    d_ptr = 0x4002b8
  }
}
gdb-peda$ p/x *(Elf64_Dyn*)$l->l_info[5]
$28 = {
  d_tag = 0x5, 
  d_un = {
    d_val = 0x400330, 
    d_ptr = 0x400330
  }
}
```
找到libc的strtab
```
gdb-peda$ p/x *(Elf64_Dyn*)$l2->l_info[5]
$29 = {
  d_tag = 0x5, 
  d_un = {
    d_val = 0x7ffff7a1dfd0, 
    d_ptr = 0x7ffff7a1dfd0
  }
}
```
这样我们可以拿到library中的各个section

保存libc的strtab和symtab
```
gdb-peda$ p/x *(Elf64_Dyn*)$l2->l_info[5]
$29 = {
  d_tag = 0x5, 
  d_un = {
    d_val = 0x7ffff7a1dfd0, 
    d_ptr = 0x7ffff7a1dfd0
  }
}
gdb-peda$ set $dynstr2 = (char*)0x7ffff7a1dfd0
gdb-peda$ p/x *(Elf64_Dyn*)$l2->l_info[6]
$31 = {
  d_tag = 0x6, 
  d_un = {
    d_val = 0x7ffff7a10d88, 
    d_ptr = 0x7ffff7a10d88
  }
}
gdb-peda$ set $dynsym2 = (Elf64_Sym*)0x7ffff7a10d88
```
查看library中的symbol
```
gdb-peda$ p/s $dynstr2 + $dynsym2[0]->st_name
$39 = 0x7ffff7a1dfd0 ""
gdb-peda$ p/s $dynstr2 + $dynsym2[1]->st_name
$40 = 0x7ffff7a21a21 "_dl_starting_up"
gdb-peda$ p/s $dynstr2 + $dynsym2[2]->st_name
$41 = 0x7ffff7a1eae7 "_rtld_global"
```
使用python
```
gdb-peda$ python
>for i in range(1000):
>   x = gdb.execute('p/s $dynstr2 + $dynsym2[%d]->st_name' % i,True,True)
>   if 'printf' in x :
>      print i,x
>end
19 $61 = 0x7ffff7a21e28 "dprintf"
30 $72 = 0x7ffff7a22040 "__vswprintf_chk"
108 $150 = 0x7ffff7a22ff5 "vasprintf"
117 $159 = 0x7ffff7a1f251 "__printf_chk"
118 $160 = 0x7ffff7a22e5a "obstack_vprintf"
127 $169 = 0x7ffff7a22d6b "_IO_vfprintf"
150 $192 = 0x7ffff7a20846 "sprintf"
165 $207 = 0x7ffff7a1edc9 "__vfwprintf_chk"
227 $269 = 0x7ffff7a23406 "__swprintf_chk"
228 $270 = 0x7ffff7a1f3b6 "vwprintf"
234 $276 = 0x7ffff7a1fefe "__vwprintf_chk"
257 $299 = 0x7ffff7a1ff92 "register_printf_modifier"
278 $320 = 0x7ffff7a2261b "_IO_fprintf"
333 $375 = 0x7ffff7a1e497 "_IO_printf"
362 $404 = 0x7ffff7a22368 "__fwprintf_chk"
407 $449 = 0x7ffff7a22b49 "__vsprintf_chk"
512 $554 = 0x7ffff7a21aab "__obstack_vprintf_chk"
526 $568 = 0x7ffff7a1e019 "vsprintf"
601 $643 = 0x7ffff7a1e49b "printf"
722 $764 = 0x7ffff7a21f0d "parse_printf_format"
724 $766 = 0x7ffff7a1e015 "_IO_vsprintf"
743 $785 = 0x7ffff7a21e5e "register_printf_specifier"
857 $899 = 0x7ffff7a2201b "swprintf"
900 $942 = 0x7ffff7a20842 "_IO_sprintf"
945 $987 = 0x7ffff7a1fa17 "vfwprintf"
983 $1025 = 0x7ffff7a2299d "__vprintf_chk"
987 $1029 = 0x7ffff7a237d3 "vsnprintf"
999 $1041 = 0x7ffff7a1e610 "__fprintf_chk"
```
printf再libc中的index
```
gdb-peda$ p/s $dynstr2 + $dynsym2[601]->st_name
$1042 = 0x7ffff7a1e49b "printf"
gdb-peda$ p/s $dynsym2[601]
$1043 = {
  st_name = 0x4cb, 
  st_info = 0x12, 
  st_other = 0x0, 
  st_shndx = 0xd, 
  st_value = 0x533c0, 
  st_size = 0xa1
}
gdb-peda$ p/s $dynstr2 + 0x4cb
$1044 = 0x7ffff7a1e49b "printf"

```
printf的地址为libc基地址+offset，为
```
gdb-peda$ p/x $l2->l_addr + 0x533c0
$1045 = 0x7ffff7a603c0
```
验证
```
gdb-peda$ x/i 0x7ffff7a603c0
   0x7ffff7a603c0 <__printf>:	sub    rsp,0xd8
```
回顾link_map方法：link_map追到libc(可知道基地址)，然后再扫过所有symtab、symstr，找到offset，然后相加，得到加载到虚拟内存中的地址







指定要载入的libc路径：
```
LD_LIBRARY_PATH=./path/to/libc
例如：
LD_LIBRARY_PATH=. ldd ./p3
```
已知两个function的address时可以在libcdb里找有没有对应的版本：libcdb.com

#### symbol resolution
